 ; vic20-ffractal.asm
 ; Copyright (C) 2021, Jeremy Dilatush.  All rights reserved.
 ; Use under the BSD 2-clause license (see bottom).
 ; 
 ; "F-Fractal" for VIC-20 (a computer of the early 1980s).
 ; Displays a 128x128 pixel bitmap of a fractal that's generated by
 ; dividing a square into four quadrants; blanking one of them; and
 ; making three copies of the whole variously rotated or mirrored.
 ;
 ; To build:
 ;       + Build on Linux or macOS command line.
 ;       + You need "crasm" and "vice" installed.
 ;           - "crasm" is the assembler used for this
 ;           - "vice" contains tools "c1541" and "petcat" which are used
 ;           for building a disk image.
 ;       + Edit the settings at the top of vic20-ffractal.mk to point to
 ;       where those things are installed on your system.
 ;       + Run "make -f vic20-ffractal.mk".
 ;       + If successful, it's created a bunch of files; the most interesting
 ;       are:
 ;           vic20-ffractal.d64
 ;               1540/1541 disk image containing the program, and a munged
 ;               copy of the assembly language source code.
 ;           vic20-ffractal.lst
 ;               Assembler output including symbol table.
 ; To start the program:
 ;       + Insert the disc imaged by "vic20-ffractal.d64" into the floppy
 ;       drive (assumed to be #8).
 ;       + Enter: LOAD "*", 8
 ;       + Enter: RUN
 ;       In the VICE emulator it's also possible to drag and drop the
 ;       "vic20-ffractal.prg" file onto the emulator, in some cases.
 ; To end the program:
 ;       Hitting run/stop will reset your system.
 ; To change the fractal:
 ;       The keys @ and A-W will each change the fractal.
 ;       Keys @ and A-G change what happens in the upper left quarter.
 ;       Keys H-O change what happens in the upper right quarter.
 ;       Keys P-W change what happens in the lower left quarter.
 ; The space bar changes the color scheme.
 ;
 ; Tested in the VICE emulator.

 ;; ;; ;; top matter

 ; config_*: Various settings you can edit to alter the resulting program.
 ;   config_exp:
 ;       Build for expanded VIC-20s.  4 possible values:
 ;           0 -- unexpanded VIC-20 only
 ;           3 -- 3k expanded VIC-20 only
 ;           8 -- 8k or 16k expanded VIC-20
 ;           99 -- auto detect and handle expansion
 ;           64 -- assemble for Commodore 64 instead of VIC-20
 ;      99 is the most versatile but makes the program longer
 ;   config_xcut:
 ;       1 cuts transformations short, giving the wrong shape but one easier
 ;       to understand for testing.  Recommended: 0
 ;   config_badc:
 ;       1 sets the background to an orange color, showing you some white stuff
 ;       that's supposed to be invisible but might be informative for testing.
 ;       Recommended: 0
 ;   config_inesw:
 ;       1 inverts the NE and SW quarters of the bitmap, for use in testing.
config_xcut = 0
config_badc = 0
config_exp = 99
config_inesw = 0

    cpu 6502
    code
    output scode
    mlist on

IF config_exp == 0
basic_base = $1001 ; start of BASIC on unexpanded VIC-20
ENDC
IF config_exp == 3
basic_base = $0401 ; start of BASIC on 3k expanded VIC-20
ENDC
IF config_exp == 8
basic_base = $1201 ; start of BASIC on 8k or 16k expanded VIC-20
ENDC
IF config_exp == 64
basic_base = $0801 ; start of BASIC on Commodore 64
ENDC
IF config_exp == 99
basic_base = $1001 ; Not necessarily right.  Depending on expansions,
                   ; the program could be loaded to $1001, $0401, or $1201.
                   ; It'll have to copy itself to another location;
                   ; $1001 seems good.
ENDC

IF config_exp != 64
; VIC-20
colors = $9600 ; color RAM
bitmap = $1800 ; 2kB bitmap
screen = $1600 ; screen memory
width = 22     ; screen width of VIC-20
height = 23    ; screen height of VIC-20
ELSE
; Commodore 64
colors = $d800 ; color RAM
bitmap = $2800 ; 2kB "bitmap" -- a character set, not using C64 bitmap mode
screen = $2000 ; 2kB screen memory
width = 40
height = 25
ENDC
getin = $ffe4 ; "GETIN" routine in ROM to read keyboard
basic_base_auto = $2b ; in zero page, address of start of BASIC
tape_buffer = $33c ; tape buffer: convenient place for machine code

 ; Text / bitmap "mode" switching depending on raster scan line.
IF config_exp != 64
; VIC-20
vr_scan = $9004; raster scan line register
textscan = $67 ; raster scan value to switch to "text mode"
bitscan = $82  ; raster scan value to switch to "bitmap mode"
vr_mode = $9005; video register controlling video memory addresses
textmode = $d2 ; $1400 part of screen addr $1600 + $8800 mixed case ROM chars
bitmode = $de  ; $1400 part of screen addr $1600 + $1800 bitmap address
ELSE
vr_scan = $d012; raster scan line register
textscan = $d8 ; raster scan value to switch to "text mode"
bitscan = $fb  ; raster scan value to switch to "bitmap mode"
vr_mode = $d018; video register controlling video memory addresses
textmode = $87 ; screen addr $2000, mixed case ROM character set (virtual) $1800
bitmode = $8b  ; screen addr $2000, bitmap character set $2800
ENDC

 ; selectNW, selectNE, selectSW:
 ; Addresses within screen memory where the current fractal "rules" are stored.
selectNW = screen + (height - 3) * width + width - 2
selectNE = screen + (height - 3) * width + width - 1
selectSW = screen + (height - 2) * width + width - 2

 ; bm_NW, bm_NE, bm_SW:
 ; Addresses within bitmap memory where the current fractal "rules" are
 ; illustrated and stored.
bm_NW = bitmap + (16 * 14 + 14) * 8
bm_NE = bitmap + (16 * 14 + 15) * 8
bm_SW = bitmap + (16 * 15 + 14) * 8

 ; Coordinate stack:
 ; Used for the recursive fractal processing.  Consists of 8 levels of 8
 ; bytes, occupying 64 bytes of unused bitmap memory.
 ; In each level:
 ;   2 byte screen coordinates of "NW" corner
 ;   1 byte direction (0-3: E S W N) from "NW" to "NE" corner
 ;   1 byte direction (0-3: E S W N) from "NW" so "SW corner
 ;   1 byte size of square being drawn at this level (128 -> 64 -> 32 -> ...)
 ;   3 bytes unused

cstak = bitmap + 1088           ; coordinate stack address
cstak_o_nw = 0                  ; NW corner within each level
cstak_o_ed = 2                  ; NW->NE leg direction (ESWN) within each level
cstak_o_sd = 3                  ; NW->SW leg direction (ESWN) within each level
cstak_o_sz = 4                  ; size of square being drawn at this level
cstak_wid = 8                   ; number of bytes per level
cstak_dep = 8                   ; number of levels

 ; Zero page space we can use

zptm1 = $fb ; 2 bytes we can use in zero page
zptm2 = $fd ; 2 bytes we can use in zero page
zptm3 = $01 ; 2 bytes we can use in zero page
            ; Not as good as $fb-$fe which the memory maps describe
            ; as "Operating system free zero page space", $01-$02 is
            ; the vector for BASIC's USR() function, which this program
            ; does not use.

 ;; ;; ;; a short prefix program in BASIC

* = basic_base

basic_1 = *
    dw basic_2, 1
    db 137 ; token for "GOTO"
    asc "9"
    db 0
basic_2 = *
    dw basic_3, 2
    asc "\"F-FRACTAL\""
    db 0
basic_3 = *
    dw basic_4, 3
IF config_exp != 64
    asc "FOR VIC-20"
ELSE
    asc "FOR COMMODORE 64"
ENDC
    db 0
basic_4 = *
IF config_exp != 64
    dw basic_5, 4
    asc "(NTSC OR PAL)"
    db 0
ENDC
basic_5 = *
IF config_exp != 99
IF config_exp != 64
    dw basic_6, 5
IF config_exp == 0
    asc "(UNEXPANDED)"
ENDC
IF config_exp == 3
    asc "(3K EXPANDED)"
ENDC
IF config_exp == 8
    asc "(8/16K EXPANDED)"
ENDC
    db 0
ENDC
ENDC
basic_6 = *
    dw basic_7, 6
    asc "BY JEREMY DILATUSH"
    db 0
basic_7 = *
IF 0
    dw basic_8, 7
    asc "MAY 2021"
    db 0
ENDC
basic_8 = *
    dw basic_9, 8
    asc ":"
    db 0
basic_9 = *
    dw basic_end, 9
    db 156 ; token for "CLR"
    db 58 ; ":"
    db 158 ; token for "SYS"
IF config_exp != 99
    ; calculate start address at assemble time
    db 48 + (start / 1000) ; address of 'start'
    db 48 + (start / 100) - (start / 1000) * 10
    db 48 + (start / 10) - (start / 100) * 10
    db 48 + start - (start / 10) * 10
ELSE
    ; calculate start address at run time
    db 194 ; token for "PEEK"
    asc "(43)"
    db 170 ; token for "+"
    db 194
    asc "(44)"
    db 172 ; token for "*"
    asc "256"
    db 170
    db 48 + (start - basic_base) / 100
    db 48 + (start - basic_base) / 10 - ((start - basic_base) / 100) * 10
    db 48 + (start - basic_base) - ((start - basic_base) / 10) * 10
ENDC
    db 0
basic_end = *
    dw 0

 ;; ;; ;; main machine language program skeleton

start = *
IF config_exp == 99
    ; Don't know where we are in memory.  That's inconvenient.  Solve
    ; it by doing the following:
    ;       + figure out where our routine 'copyem' is
    ;       + copy that to the tape buffer
    ;       + call it, to copy this whole program to where it expected
    ;       to be in the first place

    ; So, copy copyem to tape_buffer
    lda basic_base_auto         ; figure out where we really loaded
    clc
    adc #LO(copyem-basic_base)  ; to make a pointer to copyem in zptm1
    sta zptm1
    lda basic_base_auto+1       ; upper byte of that
    adc #HI(copyem-basic_base)
    sta zptm1+1
    ldy #0                      ; let X count the bytes in 'copyem'
start__copy_loop = *
    lda (zptm1), Y              ; read a byte from copyem
    sta tape_buffer, Y          ; and write it to the tape buffer
    iny                         ; and count it off
    cpy #(copyem_end-copyem)    ; are we done?
    bne start__copy_loop        ; branch if not, to copy more

    ; Having put copyem in a convenient place, set up for it and call it.
    lda basic_base_auto         ; figure out where we really loaded
    sta zptm1                   ; that'll be the source address
    lda basic_base_auto+1
    sta zptm1+1
    lda #LO(basic_base)         ; where we expect to run
    sta zptm2                   ; that'll be the destination address
    lda #HI(basic_base)
    sta zptm2+1

    jmp tape_buffer             ; and run 'copyem'
copyem__return = *
ENDC ; IF config_exp == 99

    ; The main program.  It does the following:
    ;       Initialize stuff by calling 'init'.
    ;       Then repeatedly do the following:
    ;           Wait until $9004 (raster scan line) = $67.
    ;           Set character set to text.
    ;           Wait until $9004 (raster scan line) = $82.
    ;           Set character set to bitmap.
    ;           Read a character from keyboard & process it.
    ; About those scan line thresholds:
    ;   The raster scan values in $9004 are on different scales for PAL and
    ;   NTSC, making it difficult to choose a set of thresholds that
    ;   works on both.
    ;   With the screen arrangement used here (having a few blank lines in
    ;   the middle) it's just barely possible to satisfy both video variants.
    ;   
    ;   A 1st cutoff of $65 is too low for PAL, corrupting part of the bitmap.
    ;   A 1st cutoff of $6a is too high for NTSC, corrupting part of the text.

    ;   A 2nd cutoff of $81 is too low for PAL, resulting in some of the
    ;   text being displayed as bitmap.  A 2nd cutoff of $82 is as high
    ;   as NTSC can handle (it doesn't get higher).
    ;
    ; (The above, and most of the comments, are for VIC-20.  The C-64 version
    ; uses different addresses and cutoff values.)

    lda #bitmode                ; display bitmap so you can watch it be drawn
    sta vr_mode
    jsr init                    ; set things up
main_loop__draw = *
    jsr draw                    ; draw the currently selected fractal
main_loop = *
    sei                         ; suppress interrupts which cause screen glitch
    lda vr_scan                 ; see what raster scan line we're on
    cmp #textscan               ; just wait for it to get where we want it to
    bne main_loop
    lda #textmode               ; display text at bottom of screen
    sta vr_mode
main__loop2 = *
    lda vr_scan                 ; see what raster scan line we're on
    cmp #bitscan                ; wait for it to get where we want
    bne main__loop2             ; branches if scan line != $82
    lda #bitmode                ; display bitmap at top of screen
    sta vr_mode
    cli                         ; reenable interrupts
    ; Now it's a while before we get back to raster $66; during that time,
    ; see about processing input.
    jsr getin                   ; read a character from the keyboard if any
    cmp #0                      ; did we get a character?
    beq main_loop               ; if not, just repeat the whole cycle
    ; We got a character.
    and #$7f                    ; ignore shift
    cmp #$03                    ; check for run/stop
    beq main_loop__stop
    and #$3f                    ; kludge way ignore pesky @/a gap
    cmp #$00
    bmi main_loop__notatw
    cmp #$08
    bpl main_loop__notatg
    sta selectNW                ; @/A-G modifies upper left quarter
    bmi main_loop__draw         ; branch always taken: draw & repeat
main_loop__notatg = *
    cmp #$10
    bpl main_loop__notato
    sta selectNE                ; letter H-O modifies upper right quarter
    bmi main_loop__draw         ; branch always taken: draw & repeat
main_loop__notato = *
    cmp #$18
    bpl main_loop__notatw
    sta selectSW                ; letter P-W modifies lower left corner
    bmi main_loop__draw         ; branch always taken: draw & repeat
main_loop__notatw = *
    cmp #$20                    ; space bar?
    bne main_loop               ; if not, just repeat
    jsr colorflip               ; spacebar: flip colors
    jmp main_loop
main_loop__stop = *
    ; Stop key.  Just resets the system.
    jmp ($fffc)

 ;; ;; ;; subroutines

init = *
    ; Initialize our memory and screen layout.
    ; Screen memory at $1600-$17FF:
    ;       16 rows showing a 128x128 bitmap
    ;       4 rows blank
    ;       3 rows showing info
    ; "Bitmap" character set at $1800-$1FFF.
    ; Color memory at $9600-$97FF.

    ; VIC chip configuration
    ;   Storing $96 in $9002 does the following:
    ;       sets column count to 22 ($16)
    ;       sets one bit of screen address (this program uses $1600)
    ;       sets color RAM to $9600 (which is default on unexpanded VIC-20)
IF config_exp != 64
    lda #$96
    sta $9002
    ; VIC register $9005 will be set up in main loop
    lda #$19                    ; white background, white border
IF config_badc
    lda #$99                    ; messed up colors for test/debug
ENDC
    sta $900f
ELSE
    ; Commodore 64 & its VIC-II chip.
    ; No analogue to the VIC-20's $9002 register, but *two* bytes of
    ; color registers.
    lda #$01                    ; white background, white border
    sta $d020                   ; there's the border
IF config_badc
    lda #$02                    ; messed up color for test/debug
ENDC
    sta $d021                   ; there's the background
ENDC

    ; screen & color memory initialization
    jsr screenfill              ; fill in fixed parts of screen memory
    jsr colorfill               ; set up foreground color

    rts

colorfill = *
    ; Fill in color memory, in one single color contrasting with the background.
    ; Some parts get filled in with the background instead, to hide them.
    ; Layout:
    ;       ...****************...
    ;       ...****************...
    ;       ...****************...
    ;       ...****************...
    ;       ...****************...
    ;       ...****************...
    ;       ...****************...
    ;       ...****************...
    ;       ...********...........
    ;       ...********...........
    ;       ...********...........
    ;       ...********...........
    ;       ...********...........
    ;       ...********...........
    ;       ...********......**...
    ;       ...********......**...
    ;       ......................
    ;       ......................
    ;       ......................
    ;       ......................
    ;       **********************
    ;       **********************
    ;       **********************
    ; 
    ; It's stored in color_runs in run length encoded format.  That is, each
    ; byte of it says how many character cells in a given color (background
    ; first, then foreground, etc).  The end is marked by a zero.
    ; 
    ; Uses zptm1 (2B) to point to where in color RAM it's writing.
    ; Uses zptm2 (1B) to count bytes in color_runs it's reading.
    ; Uses zptm2+1 (1B) to record the colors it's using.  Two half-byte
    ; fields, where the current one is in the low half.

    ; Figure out the colors we're going to use.
IF config_exp != 64
    lda $900f                   ; background & border color register
    and #$01                    ; extract border color (black/white)
ELSE
    lda $d020                   ; border color
    and #$01                    ; get it down to black & white
ENDC
    sta zptm2+1                 ; that's the low part: background at first
    eor #$01                    ; now make the foreground color
    asl a                       ; and put it in the high part
    asl a
    asl a
    asl a
    ora zptm2+1
    sta zptm2+1                 ; and there we have our color pair

    ; Prepare pointers.
    lda #LO(colors)             ; starting address of color RAM
    sta zptm1
    lda #HI(colors)
    sta zptm1+1
    lda #0                      ; starting index of color_runs
    sta zptm2

    ; colorfill__loop1:
    ;   Get a byte from color_runs; apply it; repeat.
colorfill__loop1 = *
    ldy zptm2                   ; getting the byte (count)
    ldx color_runs, Y           ; into X
    beq colorfill__end          ; if it's zero, we're done
    inc zptm2                   ; incrementing the index
    ldy #$0                     ; Y=0 convenient for indirect addressing
    ; colorfill__loop2:
    ;   Do one cell of the color memory.
colorfill__loop2 = *
    lda zptm2+1                 ; current choice of colors
    sta (zptm1), Y              ; write both fg & bg; only foreground is stored
    inc zptm1                   ; next byte in color memory
    bne colorfill__binc         ; branch if new byte is in same page as old
    inc zptm1+1                 ; next page of color memory
colorfill__binc = *
    dex                         ; count off this byte
    beq colorfill__new_run      ; branch if that's the end of this run
    bne colorfill__loop2        ; or if it's not
colorfill__end = *
    ; colorfill__end: end of the function colorfill; just return
    rts
colorfill__new_run = *
    ; colorfill__new_run: Swap colors and repeat outer loop.
    ; This logic to swap nybbles (half bytes) is attributed to David Galloway
    ; by Garth Wilson, whose article at http://6502.org/source/general/SWN.html
    ; I got this from.
    lda zptm2+1         ; Cy, Ac = ( ??  b3  b2  b1  b0  f3  f2  f1  f0 )
    asl a               ; Cy, Ac = ( b3  b2  b1  b0  f3  f2  f1  f0  #0 )
    adc #$80            ; Cy, Ac = ( b2 !b2  b1  b0  f3  f2  f1  f0  b3 )
    rol a               ; Cy, Ac = (!b2  b1  b0  f3  f2  f1  f0  b3  b2 )
    asl a               ; Cy, Ac = ( b1  b0  f3  f2  f1  f0  b3  b2  #0 )
    adc #$80            ; Cy, Ac = ( b0 !b0  f3  f2  f1  f0  b3  b2  b1 )
    rol a               ; Cy, Ac = (!b0  f3  f2  f1  f0  b3  b2  b1  b0 )
    sta zptm2+1
    jmp colorfill__loop1

color_runs = *
    ; Run length encoded data for 'colorfill' to use.
IF config_exp != 64
    ; VIC-20
    db 3, 16, 6, 16, 6, 16, 6, 16, 6, 16, 6, 16, 6, 16, 6, 16, 6, 8, 14
    db 8, 14, 8, 14, 8, 14, 8, 14, 8, 14, 8, 6, 2, 6, 8, 6, 1, 92, 66, 0
ELSE
    ; C-64
    db 12, 16, 24, 16, 24, 16, 24, 16, 24, 16, 24, 16, 24, 16, 24, 16, 24
    db 8, 32, 8, 32, 8, 32, 8, 32, 8, 32, 8, 32, 8, 6, 2, 24, 8, 6, 1
    db 253, 120, 0
ENDC

colorflip = *
    ; Change the color scheme.
    lda #$11                    ; black/white swap for background also border
IF config_exp != 64
    eor $900f
    sta $900f
ELSE
    eor $d020                   ; flip border
    sta $d020
    sta $d021                   ; background too
ENDC
    jmp colorfill               ; then do the foreground color & return

bitmapclear = *
    ; Empty out the bitmap so we can write to it again: 2048 bytes of zeros.
    ; Uses X & Ac.
    ldx #0                      ; X will count bytes 0-255
    txa                         ; Ac will hold the byte we want to write
bitmapclear__loop = *
    sta bitmap, X               ; six bytes this time
    sta bitmap+$100, X
    sta bitmap+$200, X
    sta bitmap+$300, X
    sta bitmap+$400, X
    sta bitmap+$500, X
    sta bitmap+$600, X
    sta bitmap+$700, X
    inx                         ; next time
    bne bitmapclear__loop       ; branch if there is a next time
    rts                         ; if not, return

screenfill = *
    ; Fill in the screen memory.  Near the top are the "characters" mapping
    ; to the bitmap (in a 16x16 grid) while lower down is some text.  Most of
    ; this will remain unchanged, except a few bytes near the bottom.

    ; Top part: 0-255 in a 16x16 grid, in the middle of the first 16 of the
    ; 22-character rows.  The address of a cell in that grid is:
    ;       screen + cell + (cell / 16) * 6 + 3
IF config_exp != 64
    ; VIC-20 version of screen address calculation
    lda #0                      ; count the character codes & grid positions
    tay                         ; Y=0 will be convenient later
    sta zptm1                   ; in zptm1
screenfill__loop1 = *
    lda zptm1                   ; Ac = cell (starting to compute address)
    lsr a                       ; cell / 2
    lsr a                       ; cell / 4
    lsr a                       ; cell / 8
    lsr a                       ; cell / 16
    asl a                       ; (cell / 16) * 2
    sta zptm1+1                 ; save that for later
    asl a                       ; (cell / 16) * 4
    clc
    adc zptm1+1                 ; Ac= (cell / 16) * 6; Carry= 0
    adc #LO(screen)+3           ; Ac= LO(screen)+3+(cell/16)*6; Carry= 0
    adc zptm1                   ; Ac= LO(screen)+3+cell+(cell/16)*6; Carry out
    sta zptm2                   ; that's low byte of cell address
    tya                         ; zero, to start computing high byte
    adc #HI(screen)             ; added with carry in
    sta zptm2+1                 ; now zptm2 points to the cell in memory
    lda zptm1                   ; get the value we want to write to it
    sta (zptm2),y               ; and write it
    inc zptm1                   ; count that byte & on to the next
    bne screenfill__loop1       ; repeat until zptm1 comes back to zero
ELSE
    ; C-64 version of screen address calculation.
    ; Algorithm:
    ;       using X to hold character cell number
    ;       using zptm2 to hold pointer to character cell
    ;       start:
    ;           zptm1 := 0
    ;           zptm2 := screen - ((width - 16) / 2)
    ;       main loop:
    ;           if zptm1 & 15 == 0:
    ;               zptm2 := zptm2 + (width - 16) ; new row
    ;           write zptm1 to memory at zptm2
    ;           increment zptm1
    ;           increment zptm2
    ;           if zptm1 != 0:
    ;               repeat main loop
    lda #0                      ; initializing the character cell counter
    tax                         ; that goes in X
    tay                         ; and Y=0 can also be convenient
    lda #LO(screen - ((width - 16) / 2)) ; initializing the pointer
    sta zptm2
    lda #HI(screen - ((width - 16) / 2))
    sta zptm2+1
screenfill__loop1 = *
    txa                         ; look at the character cell number
    and #$0f                    ; is it time for a new row?
    bne screenfill__nnr         ; branch if not
    clc                         ; new row: add (width - 16) to pointer
    lda zptm2
    adc #(width - 16)
    sta zptm2
    bcc screenfill__nnr         ; branch of that add doesn't carry
    inc zptm2+1                 ; handle carry if it does
screenfill__nnr = *
    txa                         ; now write the cell number into memory
    sta (zptm2),y
    inx                         ; increment cell counter
    beq screenfill__bottom      ; branch when that wraps around
    inc zptm2                   ; increment cell pointer
    bne screenfill__loop1       ; branch to repeat the loop (unless carrying)
    inc zptm2+1                 ; the cell pointer increment carries
    bne screenfill__loop1       ; now repeat the loop (branches always taken)
ENDC
    
    ; Bottom part: Info and fixed text, by copying 66 bytes (3 rows) from
    ; screenfill_bottom_data.
screenfill__bottom = *
    ldx #(3*width-1)            ; starting with last byte
screenfill__loop2 = *
    lda screenfill_bottom_data, X ; get that byte
    sta screen + width*(height-3), X ; and store it
    dex                         ; count it off
    bpl screenfill__loop2       ; loop until X wraps around to 255

    rts                         ; then we're done

screenfill_bottom_data = *
    ; Data for screenfill to write near the bottom of the screen.
    ; In mixed-case Commodore screen codes.
IF config_exp != 64
    ; VIC-20
    db $46,$2d,$06,$12,$01,$03,$14,$01,$0c,$20,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$20,$05,$08 ; "F-fractal           eh"
    db $02,$19,$20,$4a,$05,$12,$05,$0d,$19,$20,$44
    db $09,$0c,$01,$14,$15,$13,$08,$20,$20,$12,$20 ; "by Jeremy Dilatush  r "
    db $4d,$01,$19,$20,$32,$30,$32,$31,$20,$20,$20
    db $1b,$0b,$05,$19,$13,$20,$00,$41,$2d,$57,$1d ; "May 2021   [keys @A-W]"
ELSE
    ; C-64
    ;   "F-fractal                    Setting: eh"
    ;   "by Jeremy Dilatush                    r "
    ;   "May 2021                     [keys @A-W]"
    db $46,$2d,$06,$12,$01,$03,$14,$01,$0c,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$20,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$20,$53
    db $05,$14,$14,$09,$0e,$07,$3a,$20,$05,$08

    db $02,$19,$20,$4a,$05,$12,$05,$0d,$19,$20
    db $44,$09,$0c,$01,$14,$15,$13,$08,$20,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$20,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$12,$20

    db $4d,$01,$19,$20,$32,$30,$32,$31,$20,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$20,$20
    db $20,$20,$20,$20,$20,$20,$20,$20,$20,$1b
    db $0b,$05,$19,$13,$20,$00,$41,$2d,$57,$1d
ENDC

draw = *
    ; draw: Draw the currently selected fractal, and the transformed "F"
    ; characters that help identify it.  Acts based on the "rules" stored
    ; in screen memory at selectNW, selectNE, and selectSW.

    jsr bitmapclear             ; wipe out our drawing area

    ; Do transformed "F" symbol in upper left corner
    lda #LO(bm_NW)              ; point zptm1 to where it should be drawn
    sta zptm1
    lda #HI(bm_NW)
    sta zptm1+1
    lda selectNW                ; put the "rule" in the accumulator
    jsr draw_f                  ; do it

    ; Do transformed "F" symbol in upper right corner
    lda #LO(bm_NE)              ; point zptm1 to where it should be drawn
    sta zptm1
    lda #HI(bm_NE)
    sta zptm1+1
    lda selectNE                ; put the "rule" in the accumulator
    jsr draw_f                  ; do it

    ; Do transformed "F" symbol in lower left corner
    lda #LO(bm_SW)              ; point zptm1 to where it should be drawn
    sta zptm1
    lda #HI(bm_SW)
    sta zptm1+1
    lda selectSW                ; put the "rule" in the accumulator
    jsr draw_f                  ; do it

    ; Draw 2,187 pixels chosen by applying the rules recursively.
    ; Start by initializing a top entry in the coordinate stack.  The
    ; "bottom" of the stack will be at the highest addresses.
    lda #0
    sta cstak+(cstak_dep-1)*cstak_wid+cstak_o_nw ; NW corner: (0, 0)
    sta cstak+(cstak_dep-1)*cstak_wid+cstak_o_nw+1
    sta cstak+(cstak_dep-1)*cstak_wid+cstak_o_ed ; NW->NE direction: 0 (E)
    ldy #1
    sty cstak+(cstak_dep-1)*cstak_wid+cstak_o_sd ; NW->SW direction: 1 (S)
    ldy #128
    sty cstak+(cstak_dep-1)*cstak_wid+cstak_o_sz ; square size: 128

    ldx #(cstak_dep-1)*cstak_wid ; X will be "stack pointer" for cstak
IF config_inesw == 0
    jmp draw_rec                ; Do recursive drawing of all those pixels,
                                ; then return.
ELSE
    jsr draw_rec                ; Do recursive drawing of all those pixels
    ; For debugging: invert colors on the NE and SW quarters of the bitmap.
    ; That is, bytes whose address is:
    ;       bitmap + % 0000 0axx xbxx xxxx
    ; where
    ;       % means binary
    ;       x can be either 0 or 1, independently
    ;       a & b can be 0 & 1, or 1 & 0
    ldy #0
    sty zptm1                   ; counting off 2048 bytes in this
    sty zptm1+1
draw__inesw_loop = *
    lda zptm1                   ; see about the 'a' & 'b' bits
    lsr a
    lsr a
    lsr a
    lsr a
    eor zptm1+1
    lsr a
    lsr a
    lsr a                       ; get the EOR of those bits into carry
    bcc draw__inesw_next        ; branch if not inverting
    lda zptm1                   ; compute address, in zptm2
    clc
    adc #LO(bitmap)
    sta zptm2
    lda zptm1+1
    adc #HI(bitmap)
    sta zptm2+1
    lda (zptm2), Y              ; flip that byte of the bitmap
    eor #$ff
    sta (zptm2), Y
draw__inesw_next = *
    inc zptm1                   ; increment zptm1 to get to next bitmap byte
    bne draw__inesw_nocarry
    inc zptm1+1
draw__inesw_nocarry = *
    lda zptm1+1                 ; see if we're done with all 2048 bytes
    cmp #8
    bne draw__inesw_loop        ; if not, do this next byte
    rts                         ; or 'draw' is done
ENDC ; config_inesw

draw_f = *
    ; draw_f: Draw an "F" character, in the 7 bytes pointed to by zptm1,
    ; representing "rules" found in the low 3 bits of the accumulator.
    ; Copies 7 bytes from f_images.
    and #$07                    ; get the interesting bits
    asl a                       ; times 8 for byte offset (3 shifts)
    asl a
    asl a
    tax                         ; index into f_images
    ldy #0                      ; index into output
draw_f__loop = *
    lda f_images, X             ; get a byte from f_images
    sta (zptm1), Y              ; and store where directed
    inx                         ; count bytes
    iny
    cpy #7                      ; any left
    bmi draw_f__loop            ; repeat until 7 bytes copied
    rts                         ; then return

f_images = *
    ; Eight transformed "F" images corresponding to the eight "rule" values
    ; for each quarter.  Each is 7 bytes long but they're spaced by 8 bytes
    ; so padding is needed, except at the end.
    db $7e, $40, $40, $78, $40, $40, $40, $00 ; 0: untransformed
    db $7e, $48, $48, $48, $40, $40, $40, $00 ; 1: diagonally flipped
    db $7e, $02, $02, $1e, $02, $02, $02, $00 ; 2: horizontally flipped
    db $7e, $12, $12, $12, $02, $02, $02, $00 ; 3: diag then horiz (= right rot)
    db $40, $40, $40, $78, $40, $40, $7e, $00 ; 4: vertically flipped
    db $40, $40, $40, $48, $48, $48, $7e, $00 ; 5: diag then vert (= left rot)
    db $02, $02, $02, $1e, $02, $02, $7e, $00 ; 6: horiz then vert (= dbl rot)
    db $02, $02, $02, $12, $12, $12, $7e      ; 7: diag, horiz, vert (= ?)

draw_rec = *
    ; Recursive fractal drawing routine.  Takes info from the "coordinate stack"
    ; describing the square in which to draw, transforming and halving, until
    ; it gets to individual pixels to draw.  Expects the X register to
    ; hold a pointer into the coordinate stack, and to be nonzero.

    ; We're subdividing.  We do three quarters of the square;
    ; for each:
    ;       describe the new (halved) square: location, orientation, size
    ;       rotate/mirror as specified
    ;       recurse
    txa                     ; 'push' the coord stack down
    sec
    sbc #cstak_wid
    tax

    ; Do the upper left quarter (NW).
    lda #0                  ; NW coordinate is same as old square
    tay                     ; direction doesn't matter in that case
    jsr new_square          ; describe this new square on stack
    lda selectNW            ; read the transform rule for this quarter
    jsr transform_draw_rec  ; transform as specified & draw recursively
    
    ; Do the upper right quarter (NE).
    ldy cstak+cstak_wid+cstak_o_ed, X ; new square is to right (E) of old one
    lda cstak+cstak_wid+cstak_o_sz, X ; offset by half old square's size
    lsr a                   ; that's half
    jsr new_square          ; describe this new square on stack
    lda selectNE            ; read the transform rule for this quarter
    jsr transform_draw_rec  ; transform as specified & draw recursively

    ; Do the lower left quarter (SW).
    ldy cstak+cstak_wid+cstak_o_sd, X ; new square is down (S) from old one
    lda cstak+cstak_wid+cstak_o_sz, X ; offset by half old square's size
    lsr a                   ; that's half
    jsr new_square          ; describe this new square on stack
    lda selectSW            ; read the transform rule for this quarter
    jsr transform_draw_rec  ; transform as specified & draw recursively

    txa                     ; 'pull' the coord stack up
    clc
    adc #cstak_wid
    tax
    rts                     ; and return

draw_one = *
    ; Fill in a single pixel at coordinates found in the coordinate stack.
    ;   x coordinate at cstak+cstak_o_nw
    ;   y coordinate at cstak+cstak_o_nw+1
    ; That's by setting one bit addressed by the following mix:
    ;       bitmap + %yyy_yxxxxyyy bit xxx
    ; This logic assumes LO(bitmap)=0, and that HI(bitmap)&7=0.
    ; It preserves the X register.
    lda cstak+cstak_o_nw        ; building low byte out of X & Y coordinates
    and #$78                    ; extract the part of X going into the byte addr
    sta zptm1                   ; and temporarily store that
    lda cstak+cstak_o_nw+1      ; and do the lower Y part of it
    and #$07
    ora zptm1
    asl a                       ; temporarily times 2, for later convenience
    sta zptm1
    lda cstak+cstak_o_nw+1      ; and the upper Y part
    lsr a
    lsr a
    lsr a
    lsr a                       ; Now the 3 bits that go in the high byte are
                                ; in accumulator, and 1 bit for the low byte
                                ; is in carry.
    ora #HI(bitmap)             ; Here's where the HI(bitmap)&7=0 comes in.
    sta zptm1+1
    lda zptm1
    ror a                       ; taking off that temporary "times 2" and
                                ; shifting in the one bit of Y
    sta zptm1                   ; now zptm1 points to the byte
    lda cstak+cstak_o_nw        ; figuring out the bit (from X coordinate)
    and #$07
    tay
    lda bit_table, Y
    ldy #00                     ; and setting it
    ora (zptm1), Y
    sta (zptm1), Y
    rts

bit_table = *
    ; Bits corresponding to 8 pixels in a row
    db $80, $40, $20, $10, $08, $04, $02, $01

transform_draw_rec = *
    ; Transforms the coordinates in the coordinate stack as specified
    ; by the bottom 3 its in the accumulator (the "rule") and then calls
    ; 'draw_rec' to continue recursion.
    cpx #0                      ; see if we've reached the bottom level
    bne transform_draw_rec__notbot
    ; At the bottom level, our square has shrunk into a single pixel.
    ; There's no transformation or recursion to be done on it, just draw it.
    jmp draw_one                ; call 'draw_one' to draw it; then return
transform_draw_rec__notbot = *
IF config_xcut
    cpx #6*cstak_wid            ; stop transforming -- for test
    bpl transform__go
    jmp transform__adf          ; do "after transforming" stuff
transform__go = *
ENDC
    pha                         ; save the rule byte for later
    and #$04                    ; this bit controls vertical flipping
    beq transform__avf          ; branch to skip vertical flipping
    ; Vertical flip
    ;       "NW" corner coordinates moved E to the NE corner
    ;           by one less than the square size
    ;       "E" direction flipped
    ;       "S" direction unchanged
    ;       size unchanged
    ldy cstak+cstak_o_sd, X     ; read the "S" direction
    lda cstak+cstak_o_sz, X     ; read the square size
    sta zptm1                   ; put it where move_coords wants it
    dec zptm1                   ; and subtract one
    jsr move_coords             ; move_coords will change the NW corner coords
    lda cstak+cstak_o_sd, X     ; read the "S" direction
    eor #$02                    ; and flip it
    sta cstak+cstak_o_sd, X

transform__avf = *
    pla                         ; get back the "rule" byte
    pha                         ; but still save it for later
    and #$02                    ; this bit controls horizontal flipping
    beq transform__ahf          ; branch to skip horizontal flipping
    ; Horizontal flip
    ;       "NW" corner coordinates moved S to the SW corner
    ;           by one less than the square size
    ;       "E" direction unchanged
    ;       "S" direction flipped
    ;       size unchanged
    ldy cstak+cstak_o_ed, X     ; read the "E" direction
    lda cstak+cstak_o_sz, X     ; read the square size
    sta zptm1                   ; put it where move_coords wants it
    dec zptm1                   ; and subtract one
    jsr move_coords             ; move_coords will change the NW corner coords
    lda cstak+cstak_o_ed, X     ; read the "E" direction
    eor #$02                    ; and flip it
    sta cstak+cstak_o_ed, X

transform__ahf = *
    pla                         ; get back the "rule" byte
    and #$01                    ; this bit controls diagonal flipping
    beq transform__adf          ; branch to skip diagonal flipping
    ; Diagonal flip
    ;       "NW" corner unchanged
    ;       "E" and "W" directions swapped
    ;       size unchanged
    lda cstak+cstak_o_ed, X     ; read the "E" direction
    ldy cstak+cstak_o_sd, X     ; read the "S" direction
    sta cstak+cstak_o_sd, X     ; write them back, swapped
    tya                         ; because there's no "sta absolute, X"
    sta cstak+cstak_o_ed, X

transform__adf = *
    ; done with transforming
    jmp draw_rec                ; call 'draw_rec' & return

new_square = *
    ; new_square: Procedure to generate a new square on the coordinate stack
    ; based on the old one and some additional information passed in on
    ; registers.
    ;       Old square: cstak[X+cstak_wid]
    ;       New square: cstak[X]
    ;       Number of pixels offset from NW quarter of old square: A
    ;       Direction offset from old square: Y
    ; Uses 1 byte at zptm1 for temporary storage.
    sta zptm1                   ; convenient place to put the byte offset
    lda cstak+cstak_wid+cstak_o_nw, X ; copy X coordinate from old square to new
    sta cstak+cstak_o_nw, X
    lda cstak+cstak_wid+cstak_o_nw+1, X ; copy Y coordinate likewise
    sta cstak+cstak_o_nw+1, X
    jsr move_coords             ; now move those coordinates
    
    ; Having set up the coordinates at cstak[cstak_o_nw], take care
    ; of the remaining three bytes of the square:
    ;       cstak_o_ed (NW->NE leg direction): copy from old square
    ;       cstak_o_sd (NW->SW leg direction): copy from old square
    ;       cstak_o_sz (square size) halve it
    lda cstak+cstak_wid+cstak_o_ed, X
    sta cstak+cstak_o_ed, X
    lda cstak+cstak_wid+cstak_o_sd, X
    sta cstak+cstak_o_sd, X
    lda cstak+cstak_wid+cstak_o_sz, X
    lsr a                       ; halve it
    sta cstak+cstak_o_sz, X
    rts

move_coords = *
    ; move_coords: Procedure to move the coordinates (of the NW corner of
    ; the current square; found at cstak[X+cstak_wid]) in a given direction
    ; and distance.  The direction is given by the "Y" register while
    ; the distance is read from memory at 'zptm1'.
    cpy #0                      ; if Y=0 direction is E (right: +x)
    beq move_coords__e          ; branch if that's it
    dey
    beq move_coords__s          ; branch if direction is S (down: +y)
    dey
    beq move_coords__w          ; branch if direction is W (left: -x)
    ; Direction is N (up: -y)
    lda cstak+cstak_o_nw+1, X   ; read Y coordinate to subtract
    sec
    sbc zptm1                   ; subtract by offset to move N/up
    sta cstak+cstak_o_nw+1, X   ; and write it as new Y coordinate
    rts                         ; and done
move_coords__e = *
    ; Direction is E (right: +x)
    lda cstak+cstak_o_nw, X     ; read X coordinate to add
    clc
    adc zptm1                   ; add offset to move E/right
    sta cstak+cstak_o_nw, X     ; and write it as new X coordinate
    rts                         ; and done
move_coords__s = *
    ; Direction is S (down: +y)
    lda cstak+cstak_o_nw+1, X   ; read Y coordinate to add
    clc
    adc zptm1                   ; add offset to move S/down
    sta cstak+cstak_o_nw+1, X   ; and write it as new Y coordinate
    rts                         ; and done
move_coords__w = *
    ; Direction is W (left: -x)
    lda cstak+cstak_o_nw, X     ; read X coordinate to subtract
    sec
    sbc zptm1                   ; subtract by offset to move W/left
    sta cstak+cstak_o_nw, X     ; and write it as new square's X coord
    rts

IF config_exp == 99
    ; copyem: Copy bytes in memory:
    ;       zptm1 points to the source
    ;       zptm2 points to the destination
    ;       stops copying when destination gets to program_end
    ; For this to work ok it requires one of the following:
    ;       Either zptm1 > zptm2
    ;       Or source and destination don't overlap.
    ; When done it doesn't return like a normal subroutine, but jumps to
    ; copyem__return, because its source address might have changed.
copyem = *
    ldy #0                      ; Y=0 is convenient for indirect addressing
copyem__loop = *
    lda zptm2                   ; are we done?
    cmp #LO(program_end)
    bne copyem__dobyte          ; branch if not
    lda zptm2+1                 ; so, are we done?
    cmp #HI(program_end)
    bne copyem__dobyte          ; branch if not
    jmp copyem__return          ; all done
copyem__dobyte = *
    lda (zptm1), Y              ; read source byte
    sta (zptm2), Y              ; write destination byte
    inc zptm1                   ; increment the source pointer
    bne copyem__no1cry          ; branch if not carrying in source pointer
    inc zptm1+1                 ; carrying in source pointer
copyem__no1cry = *
    inc zptm2                   ; increment the destination pointer
    bne copyem__loop            ; branch if not carrying in destination pointer
    inc zptm2+1                 ; carrying in destination pointer
    bne copyem__loop            ; branch always assuming zptm2 never is zero
copyem_end = *
ENDC ; IF config_exp == 99

program_end = *

 ; Copyright (c) 2021 Jeremy Dilatush
 ; All rights reserved.
 ; 
 ; Redistribution and use in source and binary forms, with or without
 ; modification, are permitted provided that the following conditions
 ; are met:
 ; 1. Redistributions of source code must retain the above copyright
 ;    notice, this list of conditions and the following disclaimer.
 ; 2. Redistributions in binary form must reproduce the above copyright
 ;    notice, this list of conditions and the following disclaimer in the
 ;    documentation and/or other materials provided with the distribution.
 ; 
 ; THIS SOFTWARE IS PROVIDED BY JEREMY DILATUSH AND CONTRIBUTORS
 ; ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 ; TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 ; PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL JEREMY DILATUSH OR CONTRIBUTORS
 ; BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 ; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 ; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 ; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 ; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 ; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 ; POSSIBILITY OF SUCH DAMAGE.
